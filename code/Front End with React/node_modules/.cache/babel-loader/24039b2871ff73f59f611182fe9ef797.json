{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @module */\n\n/**\n * Marpit sweep plugin.\n *\n * Hide blank paragraphs. For better support of the background image syntax and\n * directives through HTML comment, Marpit will sweep paragraphs included only\n * whitespace by setting `hidden: true`.\n *\n * It also sweep the inline token marked as hidden forcely. Please notice that\n * plugins executed after this cannot handle hidden inline tokens.\n *\n * @alias module:markdown/sweep\n * @param {MarkdownIt} md markdown-it instance.\n */\n\n\nfunction sweep(md) {\n  md.core.ruler.after('inline', 'marpit_sweep', state => {\n    if (state.inlineMode) return;\n\n    for (const token of state.tokens) {\n      if (token.type === 'html_block' && token.content.match(/^\\s*$/) || token.type === 'inline' && token.children.filter(t => !(t.hidden || t.type === 'softbreak')).every(t => t.type === 'text' && t.content.match(/^\\s*$/))) token.hidden = true;\n    }\n  });\n  md.core.ruler.push('marpit_sweep_paragraph', state => {\n    if (state.inlineMode) return;\n    const current = {\n      open: [],\n      tokens: {}\n    };\n\n    for (const token of state.tokens) {\n      if (token.type === 'inline' && token.hidden) {\n        // markdown-it's \"inline\" type is not following a `hidden` flag. Marpit\n        // changes the token type to unique name to hide token forcely.\n        token.type = 'marpit_hidden_inline';\n      } else if (token.type === 'paragraph_open') {\n        current.open.push(token);\n        current.tokens[token] = [];\n      } else if (token.type === 'paragraph_close') {\n        const openToken = current.open.pop();\n\n        if (current.tokens[openToken].every(t => t.hidden)) {\n          openToken.hidden = true;\n          token.hidden = true;\n        }\n      } else {\n        const len = current.open.length;\n        if (len > 0) current.tokens[current.open[len - 1]].push(token);\n      }\n    }\n  });\n}\n\nvar _default = (0, _plugin.default)(sweep);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/yaozixuan/OneDrive/JHU Semester 2/OOSE/my-app/node_modules/@marp-team/marpit/lib/markdown/sweep.js"],"names":["Object","defineProperty","exports","value","default","_plugin","_interopRequireDefault","require","obj","__esModule","sweep","md","core","ruler","after","state","inlineMode","token","tokens","type","content","match","children","filter","t","hidden","every","push","current","open","openToken","pop","len","length","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module */\n\n/**\n * Marpit sweep plugin.\n *\n * Hide blank paragraphs. For better support of the background image syntax and\n * directives through HTML comment, Marpit will sweep paragraphs included only\n * whitespace by setting `hidden: true`.\n *\n * It also sweep the inline token marked as hidden forcely. Please notice that\n * plugins executed after this cannot handle hidden inline tokens.\n *\n * @alias module:markdown/sweep\n * @param {MarkdownIt} md markdown-it instance.\n */\nfunction sweep(md) {\n  md.core.ruler.after('inline', 'marpit_sweep', state => {\n    if (state.inlineMode) return;\n\n    for (const token of state.tokens) {\n      if (token.type === 'html_block' && token.content.match(/^\\s*$/) || token.type === 'inline' && token.children.filter(t => !(t.hidden || t.type === 'softbreak')).every(t => t.type === 'text' && t.content.match(/^\\s*$/))) token.hidden = true;\n    }\n  });\n  md.core.ruler.push('marpit_sweep_paragraph', state => {\n    if (state.inlineMode) return;\n    const current = {\n      open: [],\n      tokens: {}\n    };\n\n    for (const token of state.tokens) {\n      if (token.type === 'inline' && token.hidden) {\n        // markdown-it's \"inline\" type is not following a `hidden` flag. Marpit\n        // changes the token type to unique name to hide token forcely.\n        token.type = 'marpit_hidden_inline';\n      } else if (token.type === 'paragraph_open') {\n        current.open.push(token);\n        current.tokens[token] = [];\n      } else if (token.type === 'paragraph_close') {\n        const openToken = current.open.pop();\n\n        if (current.tokens[openToken].every(t => t.hidden)) {\n          openToken.hidden = true;\n          token.hidden = true;\n        }\n      } else {\n        const len = current.open.length;\n        if (len > 0) current.tokens[current.open[len - 1]].push(token);\n      }\n    }\n  });\n}\n\nvar _default = (0, _plugin.default)(sweep);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}