{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @module */\n\n/**\n * Marpit sweep plugin.\n *\n * Hide blank paragraphs. For better support of the background image syntax and\n * directives through HTML comment, Marpit will sweep paragraphs included only\n * whitespace by setting `hidden: true`.\n *\n * It also sweep the inline token marked as hidden forcely. Please notice that\n * plugins executed after this cannot handle hidden inline tokens.\n *\n * @alias module:markdown/sweep\n * @param {MarkdownIt} md markdown-it instance.\n */\n\n\nfunction sweep(md) {\n  md.core.ruler.after('inline', 'marpit_sweep', function (state) {\n    if (state.inlineMode) return;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = state.tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var token = _step.value;\n        if (token.type === 'html_block' && token.content.match(/^\\s*$/) || token.type === 'inline' && token.children.filter(function (t) {\n          return !(t.hidden || t.type === 'softbreak');\n        }).every(function (t) {\n          return t.type === 'text' && t.content.match(/^\\s*$/);\n        })) token.hidden = true;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  md.core.ruler.push('marpit_sweep_paragraph', function (state) {\n    if (state.inlineMode) return;\n    var current = {\n      open: [],\n      tokens: {}\n    };\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = state.tokens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var token = _step2.value;\n\n        if (token.type === 'inline' && token.hidden) {\n          // markdown-it's \"inline\" type is not following a `hidden` flag. Marpit\n          // changes the token type to unique name to hide token forcely.\n          token.type = 'marpit_hidden_inline';\n        } else if (token.type === 'paragraph_open') {\n          current.open.push(token);\n          current.tokens[token] = [];\n        } else if (token.type === 'paragraph_close') {\n          var openToken = current.open.pop();\n\n          if (current.tokens[openToken].every(function (t) {\n            return t.hidden;\n          })) {\n            openToken.hidden = true;\n            token.hidden = true;\n          }\n        } else {\n          var len = current.open.length;\n          if (len > 0) current.tokens[current.open[len - 1]].push(token);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  });\n}\n\nvar _default = (0, _plugin.default)(sweep);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/@marp-team/marpit/lib/markdown/sweep.js"],"names":["Object","defineProperty","exports","value","default","_plugin","_interopRequireDefault","require","obj","__esModule","sweep","md","core","ruler","after","state","inlineMode","tokens","token","type","content","match","children","filter","t","hidden","every","push","current","open","openToken","pop","len","length","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module */\n\n/**\n * Marpit sweep plugin.\n *\n * Hide blank paragraphs. For better support of the background image syntax and\n * directives through HTML comment, Marpit will sweep paragraphs included only\n * whitespace by setting `hidden: true`.\n *\n * It also sweep the inline token marked as hidden forcely. Please notice that\n * plugins executed after this cannot handle hidden inline tokens.\n *\n * @alias module:markdown/sweep\n * @param {MarkdownIt} md markdown-it instance.\n */\nfunction sweep(md) {\n  md.core.ruler.after('inline', 'marpit_sweep', state => {\n    if (state.inlineMode) return;\n\n    for (const token of state.tokens) {\n      if (token.type === 'html_block' && token.content.match(/^\\s*$/) || token.type === 'inline' && token.children.filter(t => !(t.hidden || t.type === 'softbreak')).every(t => t.type === 'text' && t.content.match(/^\\s*$/))) token.hidden = true;\n    }\n  });\n  md.core.ruler.push('marpit_sweep_paragraph', state => {\n    if (state.inlineMode) return;\n    const current = {\n      open: [],\n      tokens: {}\n    };\n\n    for (const token of state.tokens) {\n      if (token.type === 'inline' && token.hidden) {\n        // markdown-it's \"inline\" type is not following a `hidden` flag. Marpit\n        // changes the token type to unique name to hide token forcely.\n        token.type = 'marpit_hidden_inline';\n      } else if (token.type === 'paragraph_open') {\n        current.open.push(token);\n        current.tokens[token] = [];\n      } else if (token.type === 'paragraph_close') {\n        const openToken = current.open.pop();\n\n        if (current.tokens[openToken].every(t => t.hidden)) {\n          openToken.hidden = true;\n          token.hidden = true;\n        }\n      } else {\n        const len = current.open.length;\n        if (len > 0) current.tokens[current.open[len - 1]].push(token);\n      }\n    }\n  });\n}\n\nvar _default = (0, _plugin.default)(sweep);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}