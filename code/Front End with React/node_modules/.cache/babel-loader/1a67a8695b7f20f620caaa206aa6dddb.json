{"ast":null,"code":"// Process front matter and pass to cb\n//\n'use strict';\n\nmodule.exports = function front_matter_plugin(md, cb) {\n  var min_markers = 3,\n      marker_str = '-',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len = marker_str.length;\n\n  function frontMatter(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        markup,\n        token,\n        old_parent,\n        old_line_max,\n        start_content,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine]; // Check out the first character of the first line quickly,\n    // this should filter out non-front matter\n    //\n\n    if (startLine !== 0 || marker_char !== state.src.charCodeAt(0)) {\n      return false;\n    } // Check out the rest of the marker string\n    //\n\n\n    for (pos = start + 1; pos <= max; pos++) {\n      // while pos <= 3\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        start_content = pos + 1;\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n\n    pos -= (pos - start) % marker_len; // Since start is found, we can report success here in validation mode\n    //\n\n    if (silent) {\n      return true;\n    } // Search for the end of the block\n    //\n\n\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      } // closing code fence must be at least as long as the opening one\n\n\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      } // make sure tail has spaces only\n\n\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      } // found!\n\n\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container'; // this will prevent lazy continuations from ever going past our end marker\n\n    state.lineMax = nextLine;\n    token = state.push('front_matter', null, 0);\n    token.hidden = true;\n    token.markup = state.src.slice(startLine, pos);\n    token.block = true;\n    token.map = [startLine, pos];\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    cb(state.src.slice(start_content, start - 1));\n    return true;\n  }\n\n  md.block.ruler.before('table', 'front_matter', frontMatter, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n};","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/markdown-it-front-matter/index.js"],"names":["module","exports","front_matter_plugin","md","cb","min_markers","marker_str","marker_char","charCodeAt","marker_len","length","frontMatter","state","startLine","endLine","silent","pos","nextLine","marker_count","markup","token","old_parent","old_line_max","start_content","auto_closed","start","bMarks","tShift","max","eMarks","src","Math","floor","sCount","blkIndent","skipSpaces","parentType","lineMax","push","hidden","slice","block","map","line","ruler","before","alt"],"mappings":"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","sourcesContent":["// Process front matter and pass to cb\n//\n'use strict';\n\nmodule.exports = function front_matter_plugin(md, cb) {\n  var min_markers = 3,\n      marker_str  = '-',\n      marker_char = marker_str.charCodeAt(0),\n      marker_len  = marker_str.length\n\n  function frontMatter(state, startLine, endLine, silent) {\n    var pos, nextLine, marker_count, markup, token,\n        old_parent, old_line_max, start_content,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    // Check out the first character of the first line quickly,\n    // this should filter out non-front matter\n    //\n    if (startLine !== 0 || marker_char !== state.src.charCodeAt(0)) { return false; }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) { // while pos <= 3\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        start_content = pos + 1\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) { return false; }\n    pos -= (pos - start) % marker_len;\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true; }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue; }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue; }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) { continue; }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token        = state.push('front_matter', null, 0);\n    token.hidden = true;\n    token.markup = state.src.slice(startLine, pos)\n    token.block  = true;\n    token.map    = [ startLine, pos ];\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    cb(state.src.slice(start_content, start - 1))\n\n    return true;\n  }\n\n  md.block.ruler.before('table', 'front_matter', frontMatter, {\n    alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n  });\n};"]},"metadata":{},"sourceType":"script"}