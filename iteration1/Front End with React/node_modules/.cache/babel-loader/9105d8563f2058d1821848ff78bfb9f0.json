{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAsParsed = markAsParsed;\nexports.default = void 0;\n\nvar _yaml = _interopRequireDefault(require(\"./directives/yaml\"));\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @module */\n\n\nvar commentMatcher = /<!--+\\s*([\\s\\S]*?)\\s*--+>/;\nvar commentMatcherOpening = /^<!--/;\nvar commentMatcherClosing = /-->/;\nvar magicCommentMatchers = [// Prettier\n/^prettier-ignore(-(start|end))?$/, // markdownlint\n/^markdownlint-((disable|enable).*|capture|restore)$/, // remark-lint (remark-message-control)\n/^lint (disable|enable|ignore).*$/];\n\nfunction markAsParsed(token, kind) {\n  token.meta = token.meta || {};\n  token.meta.marpitCommentParsed = kind;\n}\n/**\n * Marpit comment plugin.\n *\n * Parse HTML comment as token. Comments will strip regardless of html setting\n * provided by markdown-it.\n *\n * @alias module:markdown/comment\n * @param {MarkdownIt} md markdown-it instance.\n */\n\n\nfunction comment(md) {\n  var parse = function parse(token, content) {\n    var parsed = (0, _yaml.default)(content, !!md.marpit.options.looseYAML);\n    token.meta = token.meta || {};\n    token.meta.marpitParsedDirectives = parsed === false ? {} : parsed; // Mark well-known magic comments as parsed comment\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = magicCommentMatchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var magicCommentMatcher = _step.value;\n\n        if (magicCommentMatcher.test(content.trim())) {\n          markAsParsed(token, 'well-known-magic-comment');\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n\n  md.block.ruler.before('html_block', 'marpit_comment', function (state, startLine, endLine, silent) {\n    // Fast fail\n    var pos = state.bMarks[startLine] + state.tShift[startLine];\n    if (state.src.charCodeAt(pos) !== 0x3c) return false;\n    var max = state.eMarks[startLine];\n    var line = state.src.slice(pos, max); // Match to opening element\n\n    if (!commentMatcherOpening.test(line)) return false;\n    if (silent) return true; // Parse ending element\n\n    var nextLine = startLine + 1;\n\n    if (!commentMatcherClosing.test(line)) {\n      while (nextLine < endLine) {\n        if (state.sCount[nextLine] < state.blkIndent) break;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        line = state.src.slice(pos, max);\n        nextLine += 1;\n        if (commentMatcherClosing.test(line)) break;\n      }\n    }\n\n    state.line = nextLine; // Create token\n\n    var token = state.push('marpit_comment', '', 0);\n    token.map = [startLine, nextLine];\n    token.markup = state.getLines(startLine, nextLine, state.blkIndent, true);\n    token.hidden = true;\n    var matchedContent = commentMatcher.exec(token.markup);\n    token.content = matchedContent ? matchedContent[1].trim() : '';\n    parse(token, token.content);\n    return true;\n  });\n  md.inline.ruler.before('html_inline', 'marpit_inline_comment', function (state, silent) {\n    var posMax = state.posMax,\n        src = state.src; // Quick fail by checking `<` and `!`\n\n    if (state.pos + 2 >= posMax || src.charCodeAt(state.pos) !== 0x3c || src.charCodeAt(state.pos + 1) !== 0x21) return false;\n    var match = src.slice(state.pos).match(commentMatcher);\n    if (!match) return false;\n\n    if (!silent) {\n      var token = state.push('marpit_comment', '', 0);\n      token.hidden = true;\n      token.markup = src.slice(state.pos, state.pos + match[0].length);\n      token.content = match[1].trim();\n      parse(token, token.content);\n    }\n\n    state.pos += match[0].length;\n    return true;\n  });\n}\n\nvar _default = (0, _plugin.default)(comment);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/@marp-team/marpit/lib/markdown/comment.js"],"names":["Object","defineProperty","exports","value","markAsParsed","default","_yaml","_interopRequireDefault","require","_plugin","obj","__esModule","commentMatcher","commentMatcherOpening","commentMatcherClosing","magicCommentMatchers","token","kind","meta","marpitCommentParsed","comment","md","parse","content","parsed","marpit","options","looseYAML","marpitParsedDirectives","magicCommentMatcher","test","trim","block","ruler","before","state","startLine","endLine","silent","pos","bMarks","tShift","src","charCodeAt","max","eMarks","line","slice","nextLine","sCount","blkIndent","push","map","markup","getLines","hidden","matchedContent","exec","inline","posMax","match","length","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAsParsed = markAsParsed;\nexports.default = void 0;\n\nvar _yaml = _interopRequireDefault(require(\"./directives/yaml\"));\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module */\nconst commentMatcher = /<!--+\\s*([\\s\\S]*?)\\s*--+>/;\nconst commentMatcherOpening = /^<!--/;\nconst commentMatcherClosing = /-->/;\nconst magicCommentMatchers = [// Prettier\n/^prettier-ignore(-(start|end))?$/, // markdownlint\n/^markdownlint-((disable|enable).*|capture|restore)$/, // remark-lint (remark-message-control)\n/^lint (disable|enable|ignore).*$/];\n\nfunction markAsParsed(token, kind) {\n  token.meta = token.meta || {};\n  token.meta.marpitCommentParsed = kind;\n}\n/**\n * Marpit comment plugin.\n *\n * Parse HTML comment as token. Comments will strip regardless of html setting\n * provided by markdown-it.\n *\n * @alias module:markdown/comment\n * @param {MarkdownIt} md markdown-it instance.\n */\n\n\nfunction comment(md) {\n  const parse = (token, content) => {\n    const parsed = (0, _yaml.default)(content, !!md.marpit.options.looseYAML);\n    token.meta = token.meta || {};\n    token.meta.marpitParsedDirectives = parsed === false ? {} : parsed; // Mark well-known magic comments as parsed comment\n\n    for (const magicCommentMatcher of magicCommentMatchers) {\n      if (magicCommentMatcher.test(content.trim())) {\n        markAsParsed(token, 'well-known-magic-comment');\n        break;\n      }\n    }\n  };\n\n  md.block.ruler.before('html_block', 'marpit_comment', (state, startLine, endLine, silent) => {\n    // Fast fail\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    if (state.src.charCodeAt(pos) !== 0x3c) return false;\n    let max = state.eMarks[startLine];\n    let line = state.src.slice(pos, max); // Match to opening element\n\n    if (!commentMatcherOpening.test(line)) return false;\n    if (silent) return true; // Parse ending element\n\n    let nextLine = startLine + 1;\n\n    if (!commentMatcherClosing.test(line)) {\n      while (nextLine < endLine) {\n        if (state.sCount[nextLine] < state.blkIndent) break;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        line = state.src.slice(pos, max);\n        nextLine += 1;\n        if (commentMatcherClosing.test(line)) break;\n      }\n    }\n\n    state.line = nextLine; // Create token\n\n    const token = state.push('marpit_comment', '', 0);\n    token.map = [startLine, nextLine];\n    token.markup = state.getLines(startLine, nextLine, state.blkIndent, true);\n    token.hidden = true;\n    const matchedContent = commentMatcher.exec(token.markup);\n    token.content = matchedContent ? matchedContent[1].trim() : '';\n    parse(token, token.content);\n    return true;\n  });\n  md.inline.ruler.before('html_inline', 'marpit_inline_comment', (state, silent) => {\n    const {\n      posMax,\n      src\n    } = state; // Quick fail by checking `<` and `!`\n\n    if (state.pos + 2 >= posMax || src.charCodeAt(state.pos) !== 0x3c || src.charCodeAt(state.pos + 1) !== 0x21) return false;\n    const match = src.slice(state.pos).match(commentMatcher);\n    if (!match) return false;\n\n    if (!silent) {\n      const token = state.push('marpit_comment', '', 0);\n      token.hidden = true;\n      token.markup = src.slice(state.pos, state.pos + match[0].length);\n      token.content = match[1].trim();\n      parse(token, token.content);\n    }\n\n    state.pos += match[0].length;\n    return true;\n  });\n}\n\nvar _default = (0, _plugin.default)(comment);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}