{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/yaozixuan/Document/OOSE/my-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nvar _wrap_tokens = _interopRequireDefault(require(\"../helpers/wrap_tokens\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @module */\n\n/**\n * Marpit header and footer plugin.\n *\n * At each slide, add header and footer that are provided by directives.\n *\n * @alias module:markdown/header_and_footer\n * @param {MarkdownIt} md markdown-it instance.\n */\n\n\nfunction headerAndFooter(md) {\n  md.core.ruler.after('marpit_directives_apply', 'marpit_header_and_footer', function (state) {\n    if (state.inlineMode) return;\n    var parsedInlines = new Map();\n\n    var getParsed = function getParsed(markdown) {\n      var parsed = parsedInlines.get(markdown);\n\n      if (!parsed) {\n        parsed = md.parseInline(markdown, state.env);\n        delete parsed.map;\n        parsedInlines.set(markdown, parsed);\n      }\n\n      return parsed;\n    };\n\n    var createMarginalTokens = function createMarginalTokens(tag, markdown) {\n      return (0, _wrap_tokens.default)(state.Token, \"marpit_\".concat(tag), {\n        tag: tag,\n        close: {\n          block: true\n        }\n      }, getParsed(markdown));\n    };\n\n    var current;\n    var newTokens = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = state.tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var token = _step.value;\n\n        if (token.type === 'marpit_slide_open') {\n          current = token;\n          newTokens.push(token);\n          if (current.meta && current.meta.marpitHeader) newTokens.push.apply(newTokens, _toConsumableArray(createMarginalTokens('header', current.meta.marpitHeader)));\n        } else if (token.type === 'marpit_slide_close') {\n          if (current.meta && current.meta.marpitFooter) newTokens.push.apply(newTokens, _toConsumableArray(createMarginalTokens('footer', current.meta.marpitFooter)));\n          newTokens.push(token);\n        } else {\n          newTokens.push(token);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    state.tokens = newTokens;\n  });\n}\n\nvar _default = (0, _plugin.default)(headerAndFooter);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/@marp-team/marpit/lib/markdown/header_and_footer.js"],"names":["Object","defineProperty","exports","value","default","_plugin","_interopRequireDefault","require","_wrap_tokens","obj","__esModule","headerAndFooter","md","core","ruler","after","state","inlineMode","parsedInlines","Map","getParsed","markdown","parsed","get","parseInline","env","map","set","createMarginalTokens","tag","Token","close","block","current","newTokens","tokens","token","type","push","meta","marpitHeader","marpitFooter","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nvar _wrap_tokens = _interopRequireDefault(require(\"../helpers/wrap_tokens\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module */\n\n/**\n * Marpit header and footer plugin.\n *\n * At each slide, add header and footer that are provided by directives.\n *\n * @alias module:markdown/header_and_footer\n * @param {MarkdownIt} md markdown-it instance.\n */\nfunction headerAndFooter(md) {\n  md.core.ruler.after('marpit_directives_apply', 'marpit_header_and_footer', state => {\n    if (state.inlineMode) return;\n    const parsedInlines = new Map();\n\n    const getParsed = markdown => {\n      let parsed = parsedInlines.get(markdown);\n\n      if (!parsed) {\n        parsed = md.parseInline(markdown, state.env);\n        delete parsed.map;\n        parsedInlines.set(markdown, parsed);\n      }\n\n      return parsed;\n    };\n\n    const createMarginalTokens = (tag, markdown) => (0, _wrap_tokens.default)(state.Token, `marpit_${tag}`, {\n      tag,\n      close: {\n        block: true\n      }\n    }, getParsed(markdown));\n\n    let current;\n    const newTokens = [];\n\n    for (const token of state.tokens) {\n      if (token.type === 'marpit_slide_open') {\n        current = token;\n        newTokens.push(token);\n        if (current.meta && current.meta.marpitHeader) newTokens.push(...createMarginalTokens('header', current.meta.marpitHeader));\n      } else if (token.type === 'marpit_slide_close') {\n        if (current.meta && current.meta.marpitFooter) newTokens.push(...createMarginalTokens('footer', current.meta.marpitFooter));\n        newTokens.push(token);\n      } else {\n        newTokens.push(token);\n      }\n    }\n\n    state.tokens = newTokens;\n  });\n}\n\nvar _default = (0, _plugin.default)(headerAndFooter);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}