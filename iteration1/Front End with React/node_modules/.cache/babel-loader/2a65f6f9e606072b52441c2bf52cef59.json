{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/yaozixuan/Document/OOSE/my-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../../plugin\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/** @module */\n\n\nvar styleMatcher = /<style([\\s\\S]*?)>([\\s\\S]*?)<\\/style>/i;\nvar styleMatcherOpening = /^<style(?=(\\s|>|$))/i;\nvar styleMatcherClosing = /<\\/style>/i;\nvar styleMatcherScoped = /\\bscoped\\b/i;\n/**\n * Marpit style parse plugin.\n *\n * Parse `<style>` elements as the hidden `marpit_style` token. The parsed style\n * will use in {@link ThemeSet#pack} to append the style additionally.\n *\n * `<style>` elements will strip regardless of html setting provided by\n * markdown-it.\n *\n * @alias module:markdown/style/parse\n * @param {MarkdownIt} md markdown-it instance.\n */\n\nfunction parse(md) {\n  /**\n   * Based on markdown-it html_block rule\n   * https://github.com/markdown-it/markdown-it/blob/master/lib/rules_block/html_block.js\n   */\n  md.block.ruler.before('html_block', 'marpit_style_parse', function (state, startLine, endLine, silent) {\n    // Fast fail\n    var pos = state.bMarks[startLine] + state.tShift[startLine];\n    if (state.src.charCodeAt(pos) !== 0x3c) return false;\n    var max = state.eMarks[startLine];\n    var line = state.src.slice(pos, max); // Match to opening element\n\n    if (!styleMatcherOpening.test(line)) return false;\n    if (silent) return true; // Parse ending element\n\n    var nextLine = startLine + 1;\n\n    if (!styleMatcherClosing.test(line)) {\n      while (nextLine < endLine) {\n        if (state.sCount[nextLine] < state.blkIndent) break;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        line = state.src.slice(pos, max);\n        nextLine += 1;\n        if (styleMatcherClosing.test(line)) break;\n      }\n    }\n\n    state.line = nextLine; // Create token\n\n    var token = state.push('marpit_style', '', 0);\n    token.map = [startLine, nextLine];\n    token.markup = state.getLines(startLine, nextLine, state.blkIndent, true);\n    token.meta = {};\n    token.hidden = true;\n    var matchedContent = styleMatcher.exec(token.markup);\n\n    if (matchedContent) {\n      var _matchedContent = _slicedToArray(matchedContent, 3),\n          attrStr = _matchedContent[1],\n          contentStr = _matchedContent[2];\n\n      token.content = contentStr.trim();\n      token.meta.marpitStyleScoped = styleMatcherScoped.test(attrStr.trim());\n    }\n\n    return true;\n  });\n}\n\nvar _default = (0, _plugin.default)(parse);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/yaozixuan/Document/OOSE/my-app/node_modules/@marp-team/marpit/lib/markdown/style/parse.js"],"names":["Object","defineProperty","exports","value","default","_plugin","_interopRequireDefault","require","obj","__esModule","styleMatcher","styleMatcherOpening","styleMatcherClosing","styleMatcherScoped","parse","md","block","ruler","before","state","startLine","endLine","silent","pos","bMarks","tShift","src","charCodeAt","max","eMarks","line","slice","test","nextLine","sCount","blkIndent","token","push","map","markup","getLines","meta","hidden","matchedContent","exec","attrStr","contentStr","content","trim","marpitStyleScoped","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _plugin = _interopRequireDefault(require(\"../../plugin\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module */\nconst styleMatcher = /<style([\\s\\S]*?)>([\\s\\S]*?)<\\/style>/i;\nconst styleMatcherOpening = /^<style(?=(\\s|>|$))/i;\nconst styleMatcherClosing = /<\\/style>/i;\nconst styleMatcherScoped = /\\bscoped\\b/i;\n/**\n * Marpit style parse plugin.\n *\n * Parse `<style>` elements as the hidden `marpit_style` token. The parsed style\n * will use in {@link ThemeSet#pack} to append the style additionally.\n *\n * `<style>` elements will strip regardless of html setting provided by\n * markdown-it.\n *\n * @alias module:markdown/style/parse\n * @param {MarkdownIt} md markdown-it instance.\n */\n\nfunction parse(md) {\n  /**\n   * Based on markdown-it html_block rule\n   * https://github.com/markdown-it/markdown-it/blob/master/lib/rules_block/html_block.js\n   */\n  md.block.ruler.before('html_block', 'marpit_style_parse', (state, startLine, endLine, silent) => {\n    // Fast fail\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    if (state.src.charCodeAt(pos) !== 0x3c) return false;\n    let max = state.eMarks[startLine];\n    let line = state.src.slice(pos, max); // Match to opening element\n\n    if (!styleMatcherOpening.test(line)) return false;\n    if (silent) return true; // Parse ending element\n\n    let nextLine = startLine + 1;\n\n    if (!styleMatcherClosing.test(line)) {\n      while (nextLine < endLine) {\n        if (state.sCount[nextLine] < state.blkIndent) break;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        line = state.src.slice(pos, max);\n        nextLine += 1;\n        if (styleMatcherClosing.test(line)) break;\n      }\n    }\n\n    state.line = nextLine; // Create token\n\n    const token = state.push('marpit_style', '', 0);\n    token.map = [startLine, nextLine];\n    token.markup = state.getLines(startLine, nextLine, state.blkIndent, true);\n    token.meta = {};\n    token.hidden = true;\n    const matchedContent = styleMatcher.exec(token.markup);\n\n    if (matchedContent) {\n      const [, attrStr, contentStr] = matchedContent;\n      token.content = contentStr.trim();\n      token.meta.marpitStyleScoped = styleMatcherScoped.test(attrStr.trim());\n    }\n\n    return true;\n  });\n}\n\nvar _default = (0, _plugin.default)(parse);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}